#!/usr/bin/env python3

# Copyright 2019 Xcalar, Inc. All rights reserved.
#
# No use, or distribution, of this source code is permitted in any form or
# means without a valid, written license agreement with Xcalar, Inc.
# Please refer to the included "COPYING" file for terms and conditions
# regarding the use and redistribution of this software.

import json
import logging
import os
import pprint
import requests
import sys
import time

if __name__ == '__main__':
    sys.path.append(os.environ.get('XLRINFRADIR', ''))

from py_common.env_configuration import EnvConfiguration

class JMQClient(object):

    ENV_PARAMS = {'JMQ_SERVICE_HOST': {'default': 'cvraman3.int.xcalar.com'},
                  'JMQ_SERVICE_PORT': {'default': '4000'} }

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        cfg = EnvConfiguration(JMQClient.ENV_PARAMS)
        self.url_root="http://{}:{}".format(cfg.get('JMQ_SERVICE_HOST'),
                                            cfg.get('JMQ_SERVICE_PORT'))
        self.logger.debug(self.url_root)

    def _cmd(self, *, uri, params=None):
        url = "{}{}".format(self.url_root, uri)
        self.logger.debug("GET URL: {}".format(url))
        if params:
            self.logger.debug("GET PARAMS: {}".format(params))
            response = requests.get(url, params=params, verify=False) # XXXrs disable verify!
        else:
            response = requests.get(url, verify=False) # XXXrs disable verify!
        if response.status_code != 200:
            return None
        return response.json()

    def upstream(self, *, job_name, bnum):
        params = {'job_name': job_name, 'build_number': bnum}
        return self._cmd(uri = '/jenkins_upstream', params = params)

    def downstream(self, *, job_name, bnum):
        params = {'job_name': job_name, 'build_number': bnum}
        return self._cmd(uri = '/jenkins_downstream', params = params)

    def find_builds(self, *, job_name, query, verbose=False):
        params = {'job_name': job_name, 'query': json.dumps(query)}
        if not verbose:
            params['projection'] = json.dumps({'_id': 1})

        rtn = self._cmd(uri = '/jenkins_find_builds', params = params)
        if verbose:
            return rtn
        return rtn.keys()

if __name__ == '__main__':

    # It's log, it's log... :)
    ENV_PARAMS = {'LOG_LEVEL': {'default': logging.INFO} }
    cfg = EnvConfiguration(ENV_PARAMS)
    logging.basicConfig(level=cfg.get('LOG_LEVEL'),
                        format="'%(asctime)s - %(threadName)s - %(funcName)s - %(levelname)s - %(message)s",
                        handlers=[logging.StreamHandler()])

    logger = logging.getLogger(__name__)

    import argparse

    parser = argparse.ArgumentParser()

    parser.add_argument("--job", help="jenkins job name", required=True)
    parser.add_argument("--bnum", help="jenkins build number")
    parser.add_argument("--up", help="return upstream jobs", action='store_true')
    parser.add_argument("--down", help="return downstream jobs", action='store_true')

    parser.add_argument("--peq", help="parameter equals: takes <parameter name>:<parameter val>", action='append', default=[])
    parser.add_argument("--ptrue", help="parameter true: takes <parameter name>", action='append', default=[])
    parser.add_argument("--pfalse", help="parameter false: takes <parameter name>", action='append', default=[])
    parser.add_argument("--heq", help="execution host equals: takes <host name>")
    parser.add_argument("--pass", dest="_pass", help="result is SUCCESS (pass)", action='store_true')
    parser.add_argument("--fail", help="results is FAILURE (fail)", action='store_true')
    parser.add_argument("--abort", help="job was aborted", action='store_true')

    parser.add_argument("--dlt", help="duration less-than (s)", type=int)
    parser.add_argument("--dgt", help="duration greater-than (s)", type=int)

    parser.add_argument("--after", help="executed before this many days in the past", type=int)
    parser.add_argument("--before", help="executed after this many days in the past", type=int)

    parser.add_argument("--verbose", "-v", help="verbose responses (all job data)", action='store_true')

    args = parser.parse_args()

    jmqClient = JMQClient()

    if args.up:
        if not args.bnum:
            raise ValueError("--up requires both --job and --bnum")
        print(pprint.pformat(jmqClient.upstream(job_name=args.job, bnum=args.bnum)))


    if args.down:
        if not args.bnum:
            raise ValueError("--down requires both --job and --bnum")
        print(pprint.pformat(jmqClient.downstream(job_name=args.job, bnum=args.bnum)))

    query = {}
    for item in args.peq:
        print("peq: {}".format(item))
        name,val = item.split(':')
        query["parameters.{}".format(name)] = val

    for item in args.ptrue:
        print("true: {}".format(item))
        query["parameters.{}".format(item)] = True

    for item in args.pfalse:
        print("false: {}".format(item))
        query["parameters.{}".format(item)] = False

    if args.heq:
        query['built_on'] = args.heq

    if args._pass:
        query['result'] = 'SUCCESS'

    if args.fail:
        query['result'] = 'FAILURE'

    if args.abort:
        query['result'] = 'ABORTED'

    if args.dlt:
        query['duration_ms'] = {'$lt': (args.dlt * 1000)}

    if args.dgt:
        query['duration_ms'] = {'$gt': (args.dgt * 1000)}

    if args.bnum:
        query['_id'] = args.bnum

    def _days_ago_ms(days):
        return (time.time()-(days*24*60*60))*1000

    if args.after and args.before:
        after = _days_ago_ms(args.after)
        before = _days_ago_ms(args.before)
        query['$and'] = [{'start_time_ms':{'$lt': _days_ago_ms(args.before)}},
                         {'start_time_ms':{'$gt': _days_ago_ms(args.after)}}]

    elif args.after:
        query['start_time_ms'] = {'$gt': _days_ago_ms(args.after)}

    elif args.before:
        query['start_time_ms'] = {'$lt': _days_ago_ms(args.before)}

    print("query {}".format(query))
    resp = jmqClient.find_builds(job_name = args.job,
                                 query = query,
                                 verbose = args.verbose)
    if not args.verbose:
        # Just a list of matching build numbers
        for bnum in resp:
            print(bnum)
        sys.exit(0)
    print(pprint.pformat(resp))

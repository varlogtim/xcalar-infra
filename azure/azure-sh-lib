#!/bin/bash
#
# Handy Azure aliases/shortcuts. Source this file in your ~/.bash_aliases
# ## ~/.bash_aliases
# export XLRINFRADIR=$HOME/xcalar-infra
# . $XLRINFRADIR/azure/azure-sh-lib

source $XLRINFRADIR/bin/infra-sh-lib


az_setup() {
    AZ_CACHEDIR="$HOME/.cache/azure"
    HTTPCACHE="http://netstore.int.xcalar.com/infra/azure/allvms.json"
    AZ_ALLVMS="$AZ_CACHEDIR/allvms.json"
    HOSTED_ZONEID="Z2S03H582J2UUD" ## .xcalar.io
    TODAY=$(date +%Y%m%d)
    NOW="${TODAY}$(date +%H%M%S)"
    TEMPLATE=$XLRINFRADIR/azure/xdp-standard/mainTemplate.json
    TEMPLATE_URL=https://xcrepo.blob.core.windows.net/public/xdp-standard-platform/v9/mainTemplate.json
    DEFAULTS=$XLRINFRADIR/azure/xdp-standard/$(basename $TEMPLATE .json).defaults.json

    AZ_PUBLIC_ACCOUNT=${AZ_PUBLIC_ACCOUNT:-xcrepo}
    AZ_PUBLIC_CONTAINER=${AZ_PUBLIC_CONTAINER:-public}
    AZ_PUBKEY="${AZ_PUBKEY:-ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCkSfi00gfzVoaqLs/Col/kNNg2jGHNhP3LA6OykWt1ev04CbNCiGB01+wgPy6Jx0aKvA7Mx7a4cUCJs8NvgH0wfgzLo0HAcAdMoXHl7ZE6psOR5/w7WJEFZ4xd7v9WanAsONtgS5iLwuzHkMvrImO6aOz2YxzYoNRpVbsJ5PViD9EkRyaEPLRI0A9/DFY96o/xRT/EXxT2ekjJ9loIkeU2Cxs1k0R0TYxPORAvuaM2HHQ12fG51wSNkc3WQ7ehLlULjnxyanptLTDGlU6CwN0i7YEbqr8gpCw510KJg75TqxB8pBxBuN0RHacsf6Lgz/rSw97ryox/ynCzQT9hrE9b azureuser@xdp-standard}"
    AZ_DEFAULT_TEMPLATE="$TEMPLATE_URL"
    az_export_all
}


az_login() {
    az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID && \
    az account set --subscription $AZURE_SUBSCRIPTION_ID
}

az_mktemp() {
    mktemp "$@" ${TMPDIR:-/tmp}/azure-sh-lib.XXXXXX
}

az_version() {
    az --version | head -1 | sed -r 's/^(azure-cli).*\(([0-9]+)\.([0-9]+)\.([0-9]+)\)$/\2 \3 \4/g'
}

az_rg_exists() {
    [[ "$(az group exists -g $1 -otsv)" == true ]]
}

az_meta() {
    curl --connect-timeout 1 --fail --silent -H Metadata:True "$@"
}

az_rg_create() {
    local name="$1"
    local location=${2:-${LOCATION:-westus2}}
    az_rg_exists "$name" || [[ "$(az group create -n "$name" -l $location -ojson --query 'properties.provisioningState' -otsv)" == Succeeded ]]
}

# Returns Azure instance metadata like this:
# LOCATION=westus2
# NAME=trial-rmadugula-01-vm0
# OFFER=CentOS
az_metadata_instance() {
    az_meta "http://169.254.169.254/metadata/instance?api-version=2018-04-02&format=json" | jq -r ".compute|to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]" | sed -re 's/^([^=]+)=/\U\1=/g'
}

# Returns any scheduled events in this format:
## { "DocumentIncarnation": 0, "Events": [] }
az_metadata_event() {
    az_meta "http://169.254.169.254/metadata/scheduledevents?api-version=2018-04-02&format=json" | jq -r . #| jq -r ".compute|to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]" | sed -re 's/^([^=]+)=/\U\1=/g'; echo "${PIPESTATUS[0]}";
}

# Render tags as:
#
az_metadata_tags_nodeps() {
    az_meta 'http://169.254.169.254/metadata/instance/compute/tags?api-version=2018-04-02&format=text' | tr ';' '\n' | sed -r 's/^(.*):(.*)$/\1="\2"/g'
}

az_metadata_env() {
    (
        set -eo pipefail
        local tmp
        tmp="$(az_mktemp -d)"
        az_meta 'http://169.254.169.254/metadata/instance?api-version=2018-04-02&format=json' \
            | jq -r ".compute|to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]" | sed -re 's/^([^=]+)=/AZ_\U\1 /g' \
            | while read KEY VALUE; do
                echo "${KEY//-/_}=\"${VALUE}\""
            done | tee $tmp
        . $tmp
        if [ -n "$AZ_TAGS" ]; then
            echo "$AZ_TAGS" | tr ';' '\n' | sed -r 's/^([^:]+):/AZ_TAG_\U\1 /g' | while read KEY VALUE; do echo "${KEY//-/_}=\"${VALUE}\""; done | tee -a $tmp
        fi
        az_meta 'http://169.254.169.254/metadata/instance?api-version=2018-04-02&format=json' \
            | jq -r '.network.interface[0].ipv4.ipAddress[0]|[.privateIpAddress,.publicIpAddress]|@tsv' \
            | while read LOCALIP4 PUBLICIPV4; do
                echo "AZ_LOCALIPV4=${LOCALIP4}"
                test -z "$PUBLICIPV4" || echo "AZ_PUBLICIPV4=${PUBLICIPV4}"
            done | tee -a $tmp
        . $tmp
        test -z "$AZ_PUBLICIPV4" || echo "AZ_DNSLABEL=${AZ_NAME}.${AZ_LOCATION}.cloudapp.azure.com"
        rm -f $tmp
    )
    return $?
}

az_vm_ids() {
    az vm list -ojson "$@" | jq -r '.[].id'
}

az_groups() {
    mkdir -p "$AZ_CACHEDIR"
    local groups=$AZ_CACHEDIR/allgroups.json name group groupdir
    az group list -ojson > $groups
    jq -r '.[].id' < $groups > $AZ_CACHEDIR/allgroups.txt
    groupdir=$AZ_CACHEDIR/groups/${NOW}
    mkdir -p $groupdir
    for name in $(cat $AZ_CACHEDIR/allgroups.txt); do
        name=$(basename $name)
        echo >&2 "Updating $name ..."
        az group show -g ${name} -ojson > $groupdir/${name}.json
    done
    ln -sfn $NOW $groupdir/../current
}

az_rg_vms() {
    az vm list -g "$1" -ojson --query '[].id' -otsv
}

# For all vms in group $1 perform action $2
# eg, az_rg_vms_do abakshi-50-rg deallocate
az_rg_vms_do() {
    local action=$1 rg="$2" ids=()
    if [ -z "$rg" ]; then
        error "Must specify at least one resource group"
        return 1
    fi
    if [ "$action" == "stop" ]; then
        error "Please don't ever stop instances!! We will still be charged! Use 'deallocate'"
        return 1
    fi

    shift 2
    ids+=($(az_rg_vms $rg))
    if [ "${#ids[@]}" -eq 0 ]; then
        return 0
    fi
    local pids=() id
    for id in "${ids[@]}"; do
        say az vm $action "$@" --ids "$id"
        az vm $action "$@" --ids "$id" < /dev/null &
        pids+=($!)
    done
    say "Waiting for action $action to finish"
    wait "${pids[@]}"

}

az_rg_vms_stop_start_all() {
    local rg="$1" rc ip
    if [ -z "$rg" ] || [ "$(az group exists -g $rg -otsv)" != true ]; then
        error "Need to specify existing resource group"
        return 1
    fi
    if ! ip="$(az_rg_dns_or_ip "$rg")" || [ -z "$ip" ]; then
        error "Couldn't find IP for RG: $ip"
        return 1
    fi
    az_rg_vms_do deallocate $rg \
        && az_rg_vms_do start $rg
    rc=$?
    if [ $rc -ne 0 ]; then
        error "$rc: Failed to stop/start RG $rg"
        return 1
    fi
    if ! ip="$(az_rg_dns_or_ip "$rg")"; then
        warn "Unable to get IP of $rg, it may still be booting up."
        return 0
    fi
    until ssh $ip; do
        echo "Waiting for $ip (RG: $1) to come up ..."
    done
}

az_rg_pip() {
    az resource list -g "$1" --namespace Microsoft.Network --resource-type publicIPAddresses -ojson --query '[].id' -otsv
}

az_rg_stop() {
    az_rg_vms_do deallocate "$@"
}

az_rg_deallocate() {
    az_rg_vms_do deallocate "$@"
}

az_rg_start() {
    az_rg_vms_do start "$@"
}

# Pass an Azure publicIPAddress resource like
# /subscriptions/861014e9-bb2e-40ff-b6f6-85a511035bfd/resourceGroups/test-1-rg/providers/Microsoft.Network/publicIPAddresses/centos74PublicIP
az_rg_ip() {
    local rg="$1" ip_id ip_data ip
    if ! ip_id=$(az vm list-ip-addresses -g "$rg" -ojson --query '[0].virtualMachine.network.publicIpAddresses[0].id' -otsv) || test -z "$ip_id"; then
        return 1
    fi
    if ! ip_data=$(az resource show --ids "$ip_id" -ojson); then
        return 1
    fi
    if ip="$(jq -r .properties.ipAddress <<< $ip_data)" && test -n "$ip" && test "$ip" != null; then
        echo $ip
        return 0
    fi
    return 1
}

az_rg_dns_or_ip() {
    local rg="$1" ip_id ip_data dns ip
    if ! ip_id=$(az vm list-ip-addresses -g "$rg" -ojson --query '[0].virtualMachine.network.publicIpAddresses[0].id' -otsv) || test -z "$ip_id"; then
        return 1
    fi
    if ! ip_data=$(az resource show --ids "$ip_id" -ojson); then
        return 1
    fi
    if dns="$(jq -r .properties.dnsSettings.fqdn <<< $ip_data)" && test -n "$dns" && test "$dns" != null; then
        echo $dns
        return 0
    fi
    if ip="$(jq -r .properties.ipAddress <<< $ip_data)" && test -n "$ip" && test "$ip" != null; then
        echo $ip
        return 0
    fi
    return 1
}

az_ssh() {
    local host="$1"
    shift
    ssh -A -oStrictHostKeyChecking=no -oLogLevel=ERROR -oUserKnownHostsFile=/dev/null -i ~/.ssh/id_azure "$@" azureuser@${host}
}

az_rg_ssh() {
    local pip ip dns
    if pip=$(az_rg_pip "$1") && test -n "$pip"; then
        shift
        if dns="$(az resource show --ids "$pip" -ojson --query 'properties.dnsSettings.fqdn' -otsv)" && test -n "$dns"; then
            ssh $dns "$@"
            return 0
        fi
    fi
    return 1
}

az_dns() {
    local location
    if ! location=$(az group show -g $1 -ojson --query location -otsv); then
        return 1
    fi
    echo "$1.${location}.cloudapp.azure.com"
}

# The deploy.sh scripts from exportTemplate function gives shell scripts with Windows
# line endings. This function will take a filename (or stdin) and print the fixed version
# to stdout
az_fix_deploysh() {
    local tmp=$(az_mktemp)
    (
        set -e
        if test -f "$1"; then
            dos2unix -q -n "$1" $tmp
        else
            cat - > $tmp
            dos2unix -q $tmp
        fi
        sed '/^$/d' $tmp | sed -e 's/^#/\n#/g' | shfmt -i 2 -ci
        rm -f $tmp
    )
}

az_vm_cache() {
    http_proxy= https_proxy= curl "${HTTPCACHE}" -s -o $AZ_ALLVMS
}

az_vms() {
    if [ "$(file_age $AZ_ALLVMS)" -gt $((3 * 60 * 60)) ] || [ "$1" = "-f" ]; then
        az_vm_cache > $AZ_ALLVMS || return 1
    fi
    cat "${AZ_ALLVMS}"
}

az_vm_running() {
    local subs="$(az account list -otsv 2> /dev/null | awk '{print $2}')"
    az_vm_details | grep running #| tr -d "'" | awk '{printf("/subscriptions/'${subs}'/resourceGroups/%s/providers/Microsoft.Compute/virtualMachines/%s\n",tolower($1),$2)}'
}

az_vm_details_update() {
    mkdir -p "$AZ_CACHEDIR" \
        && az vm list -d -ojson > "${AZ_ALLVMS}.tmp" \
        && mv -f "${AZ_ALLVMS}.tmp" "${AZ_ALLVMS}"
    return
}

az_vm_details() {
    az_vms | jq -r '.[]|[.resourceGroup,.name,.hardwareProfile.vmSize,.powerState,.publicIps]|@sh' | column -t #jq -r '.[]|[.resourceGroup,.name,.hardwareProfile.vmSize,.powerState,.publicIps ]|@tsv' | column -t
}

az_provider_api_versions() {
    az provider show --namespace "${1:-Microsoft.Compute}" --query "resourceTypes[].[resourceType,apiVersions[]]" --out table
}

az_provider_operations() {
    # JQ version for reference
    # az provider operation show --namespace "${1:-Microsoft.Compute}" -ojson | jq -r '.resourceTypes[].operations[]|[.name,.description]'
    az provider operation show --namespace "${1:-Microsoft.Compute}" -ojson --query 'resourceTypes[].operations[].[name,description]' -otable
}

az_provider_resource() {
    # JQ version for reference
    # az provider operation show --namespace "${1:-Microsoft.Compute}" -ojson | jq -r '.resourceTypes[].operations[]|[.name,.description]'
    az provider operation show --namespace "${1:-Microsoft.Compute}" -ojson --query 'resourceTypes[].[name]' -otable
}

az_provider_operations_list() {
    az provider operation show --namespace "${1:-Microsoft.Storage}" -ojson --query "resourceTypes[?name=='storageAccounts'].operations[].name | [?contains(@, 'list')]"
}

az_blob_upload_public() {
    local fname="$1"
    test -f "$fname" || return 1
    local name="${2:-$fname}"
    local no_cache="--content-cache-control no-cache,no-store,must-revalidate,max-age=0,no-transform"
    az storage blob upload -f "$fname" -n "$name" --account-name ${AZ_PUBLIC_ACCOUNT} --container-name "${AZ_PUBLIC_CONTAINER}" $no_cache > /dev/null \
        && az storage blob url --account-name ${AZ_PUBLIC_ACCOUNT} --container-name "${AZ_PUBLIC_CONTAINER}" --name "$name" -otsv
}

az_blob_upload_batch_public() {
    local src="$1"
    local dst="$2"
    local no_cache="--content-cache-control no-cache,no-store,must-revalidate,max-age=0,no-transform"
    az storage blob upload-batch --account-name ${AZ_PUBLIC_ACCOUNT} --destination "${AZ_PUBLIC_CONTAINER}" $no_cache --source "$src" --destination-path "$dst" \
        && az storage blob url --account-name ${AZ_PUBLIC_ACCOUNT} --container-name "${AZ_PUBLIC_CONTAINER}" --name "$dst" -otsv
}

# For a given storage url, such as https://xcrepo.blob.core.windows.net/builds/prod/xcalar-1.4.1-2538-installer?foo=bart&s=x
# break it down into account, container and blob so we can generate tokens for it
az_blob_from_url() {
    # Remove any query params
    local url="${1%%\?*}"

    # remove protocol
    url="${url#https://}"
    url="${url#http://}"

    # If after all that, we have the same string something is wrong
    # or we were passed an empty string/no argument
    if [ "$url" = "$1" ]; then
        echo >&2 "ERROR: Invalid URL $1"
        return 1
    fi

    # extract host part, eg xcrepo.blob.core.windows.net
    local host="${url%%/*}"
    local account="${host%.blob.core.windows.net}"

    # get the path to the file, eg builds/prod/xcalar-1.4.1-2538-installer
    local path="${url#*/}"

    # Remove all but the first portion, eg builds
    local container="${path%%/*}"

    # Remove only the first portion, eg prod/xcalar-1.4.1-2538-installer
    local blob="${path#*/}"

    # Be sure to quote the blob, because it can have spaces
    echo "$account $container $(printf '%q' "$blob")"
}

az_blob_url_public() {
    az storage blob url --account-name ${AZ_PUBLIC_ACCOUNT} --container-name "${AZ_PUBLIC_CONTAINER}" --name "$1" -otsv
}

az_blob_container_du() {
    az storage blob list --account-name "$1" --container-name "$2" --query "[*].[properties.contentLength]" --output tsv | tee "${1}_${2}.tsv" | paste --serial --delimiters=+ | bc
}

az_storage_accounts() {
    az storage account list -ojson --query '[*].id' --output tsv
}

az_containers() {
    az storage container list --account-name $(basename $1) --output json --query '[*].name' --output tsv
}

az_container_size() {
    local account_id account container bn
    for account_id in $(az_storage_accounts); do
        account=$(basename $account_id)
        for container in $(az_containers $account); do
            echo "$account/$container: $(az_blob_container_du $account $container)"
        done
    done
}

# Returns the entire json document
az_meta_json() {
    az_meta "http://169.254.169.254/metadata/instance?api-version=2018-04-02&format=json"
}

# az_meta_text <key>, for example compute/name
az_meta_text() {
    az_meta "http://169.254.169.254/metadata/instance/$1?api-version=2018-04-02&format=text"
}

## Resource group level functions
az_rg_ips() {
    az vm list-ip-addresses --resource-group "$1" --output json --query '[].virtualMachine.network.publicIpAddresses[].[name,ipAddress]' --output tsv
}

az_rg_url() {
    local readonly group_info
    if ! group_info=($(az group show -g $1 -otsv)) && [ -n "${group_info[0]}" ]; then
        return 1
    fi
    echo "https://portal.azure.com/#resource${group_info[0]}/${2:-overview}" # could be deployments
}

az_rg_deployment_url() {
    az_rg_url "$1" "deployments"
}

az_browse() {
    local url browser
    if ! url="$(az_rg_url "$1")"; then
        return 1
    fi
    if test -z "$DISPLAY"; then
        echo "browser $url"
        return 0
    fi
    if [[ $OSTYPE =~ darwin ]]; then
        open "$url"
    elif [[ $OSTYPE =~ linux ]]; then
        xdg-open "$url"
    else
        say "Failed to find a browser: Url is $url"
    fi
}

# Example:
# $ curl http://localhost:50342/oauth2/token --data "resource=https://management.azure.com/" -H Metadata:true
#{ "access_token": "eyJ0.....4iHCdf7hB", "expires_in": "3599", "expires_on": "1521513683", "not_before": "1521509783", "resource": "https://management.azure.com/", "token_type": "Bearer" }

az_msi() {
    curl -s http://localhost:50342/oauth2/token --data "resource=https://management.azure.com/" -H Metadata:true
}

list_functions() {
    grep '^[a-z]' | grep '{$' | awk '{print $1}' | tr '\n' ' '
}

az_export_all() {
    export AZ_PUBLIC_ACCOUNT AZ_PUBLIC_CONTAINER AZ_PUBKEY AZ_DEFAULT_TEMPLATE
    export -f safe_curl say error file_age az_version az_rg_vms az_rg_vms_do az_rg_vms_stop_start_all az_rg_pip az_rg_dns_or_ip az_rg_ssh \
        az_fix_deploysh az_vms az_vm_running az_vm_details_update az_vm_details az_provider_api_versions az_blob_upload_public az_meta_json az_meta_text az_rg_deployment_url \
        az_browse list_functions az_msi az_container_size az_containers az_storage_accounts az_deploy az_deploy_usage \
        az_disk_info az_disk_update az_rg_scheduled_shutdown
}

az_sub_browse() {
    local subscription
    subscription=$(az account show -ojson --query 'id' -otsv)
    if [ $? -ne 0 ] || [ -z "$subscription" ]; then
        echo >&2 "Failed to get subscription"
        return 1
    fi
    local url="https://resources.azure.com/subscriptions/${subscription}/resourceGroups"
    if [ -n "$DISPLAY" ]; then
        chrome "$url"
    else
        echo "$url"
    fi
}

az_sp_find_homepage() {
    az ad sp list -ojson --query "[?additionalProperties.homepage=='$1']" -otable
}

az_sp_list() {
    az ad sp list -ojson --query '[].{Id: objectId, SPN: servicePrincipalNames[0]}' -otable
}

az_deploy_usage() {

    local -a params=($(jq -r '.parameters|keys|join("\n")' < $TEMPLATE | tr '\t' '\n')) str=()
    local ii
    for ii in "${params[@]}"; do
        str+=("[${ii}=]")
    done

    cat << EOF
    az_deploy [-g|--group grp] [-l|--location loc] [-i|--installer-url url] [--dnslabel dns]
              [--size vmSize] [--count num] [--template-uri http://..] [--template-file file.json]
              [-n|--name name] [--dnslabel dns] ${str[*]}
EOF
    return 0
}

az_deploy() {
    local uid=$((RANDOM % 511)) template ii cmd location=westus2
    local -a extra_params=()
    local email=$(git config user.email) retry ip_address
    local name group count=1 size=Standard_E8s_v3 template_arg storageAccount_arg
    local template=$AZ_DEFAULT_TEMPLATE
    local parameters_file=${DEFAULTS}
    local installer_url dnslabel
    while [ $# -gt 0 ]; do
        cmd="$1"
        case "$cmd" in
            -h | --help)
                az_deploy_usage
                return 1
                ;;
            --email=)
                email="${1##*=}"
                shift 1
                ;;
            --location=)
                location="${1##*=}"
                shift 1
                ;;
            --group= | --resource-group=)
                group="${1##*=}"
                shift 1
                ;;
            --template-file=)
                template="${1##*=}"
                shift 1
                ;;
            --template-uri=)
                template="${1##*=}"
                shift 1
                ;;
            --parameters-file=)
                parameters_file="${1##*=}"
                shift 1
                ;;
            --count=)
                count="${1##*=}"
                shift 1
                ;;
            --dnslabel=)
                dnslabel="${1##*=}"
                shift 1
                ;;
            --size=)
                size="${1##*=}"
                shift 1
                ;;
            --name=)
                name="${1##*=}"
                shift 1
                ;;
            --installer-url=)
                installer_url="${1##*=}"
                extra_params+=(installerUrl="${1##*=}")
                shift 1
                ;;
            -l | --location)
                location="$2"
                shift 2
                ;;
            -g | --group | --resource-group)
                group="$2"
                shift 2
                ;;
            -n | --name)
                name="$2"
                shift 2
                ;;
            --email)
                email="$2"
                shift 2
                ;;
            --template-file)
                template="$2"
                shift 2
                ;;
            --template-uri)
                template="$2"
                shift 2
                ;;
            --parameters-file)
                parameters_file="$2"
                shift 2
                ;;
            --count)
                count="$2"
                shift 2
                ;;
            --dnslabel)
                dnslabel="$2"
                shift 2
                ;;
            --size)
                size="$2"
                shift 2
                ;;
            -i | --installer-url)
                installer_url="$2"
                extra_params+=(installerUrl="$2")
                shift 2
                ;;
            --parameters)
                shift
                break
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo >&2 "Unknown arg: $cmd"
                az_deploy_usage
                return 1
                ;;
            *) break ;;
        esac
    done
    if [ -n "$group" ] && [ -z "$name" ]; then
        if ! [[ $group =~ -rg$ ]]; then
            die "Resource group must end in -rg"
        fi
        name="${group%-rg}"
    fi
    test -n "$name" || name="xdp-${USER}-${uid}"
    test -n "$dnslabel" || dnslabel="${name}"

    if [ "$(az group exists -g "$group" -otsv)" = false ]; then
        say "Must specify resource group with -g <resource group>"
        say "Please create a resource group first, for example:"
        say ""
        say " az group create -g ${name}-rg -l westus2"
        say ""
    fi

    case "$template" in
        https://* | http://*) template_arg="--template-uri $template" ;;
        *) template_arg="--template-file $template" ;;
    esac

    if [ "$location" = westus2 ]; then
        storageAccount_arg="storageAccountNewOrExisting=existing storageAccountRG=xcalarroot-rg storageAccountName=xcalarroot"
    else
        storageAccount_arg="storageAccountNewOrExisting=new"
    fi
    local TMP="$(az_mktemp)"

    az group deployment validate -g $group $template_arg \
        --parameters ${parameters_file+@$parameters_file} "appName=${name}" \
        "adminEmail=$email" domainNameLabel=${dnslabel} "${extra_params[@]}" \
        vmSize=$size scaleNumber=$count "$@" -ojson | tee "$TMP" > /dev/null
    rc=${PIPESTATUS[0]}
    if [ $rc != 0 ]; then
        cat "$TMP" >&2
        say "Failed to validate!"
        return 1
    fi

    say
    say "Deploying to $group.. you can browse your resource group here: $(az_rg_url $group)"
    say " and your deployment here: $(az_rg_deployment_url $group)"
    say

    az group deployment create --name deploy-${NOW} -g $group $template_arg \
        --parameters ${parameters_file+@$parameters_file} "appName=${name}" \
        "adminEmail=$email" domainNameLabel=${dnslabel} "${extra_params[@]}" \
        vmSize=$size scaleNumber=$count "$@" -ojson | tee "$TMP"
    rc=${PIPESTATUS[0]}
    if [ $rc != 0 ]; then
        say "Failed to deploy!"
        return 1
    fi
    az_rg_scheduled_shutdown $group 2359

    local dns=${dnslabel}.${location}.cloudapp.azure.com

    say "Finished. Browse your deployment here: https://${dns}"
    say
    say "You can ssh into the head node of your cluster: ssh azureuser@${dns}"
    say
    say "Finally, you can delete your cluster: az group delete -g $group"
    say
}

# Call this function with the resourceGroup name and optionally
# a time in 24h (default 2200 = 10pm PST). This will deploy
# shutdown rules to all vms in the resourcegroups.
az_rg_scheduled_shutdown() {
    local group="$1" time="${2:-2200}"
    if [ -z "$group" ]; then
        echo >&2 "Need to specify resource group"
        return 1
    fi
    local -a vms=($(az vm list -g "$group" --query '[].id' -otsv))
    local count="${#vms[@]}"
    local vm0="${vms[0]}"
    vm0="${vm0##*/}"
    az group deployment create -n scheduledShutdown-${NOW} -g $group --template-file $XLRINFRADIR/azure/arm/scheduledShutdown/scheduledShutdown.json --parameters vmName="${vm0%[0-9]*}" time=${time} timeZoneId='Pacific Standard Time' scaleNumber=$count -ojson --no-wait
}

az_disk_info() {
    az disk list -ojson | jq -r '[.[]|{id:.id, sku:.sku.name,size:.diskSizeGb}]'
}

az_disk_update() {
    local cluster="$1" size_gb="${2:-127}" storage_sku="${3:-StandardSSD_LRS}" disks=''
    disks=($(az disk list -otsv | grep "$cluster" | awk '{print $5}'))

    az disk update --sku StandardSSD_LRS --size-gb $size_gb --ids ${disks[@]}
}

az_setup

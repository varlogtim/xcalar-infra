#!/bin/bash

AWS_AMI_OWNER_REDHAT=309956199498
AWS_AMI_OWNER_CANONICAL=099720109477
AWS_AMI_MARKETPLACE=679593333241
AWS_AMI_FILTERS=('Name=state,Values=available' 'Name=architecture,Values=x86_64' 'Name=virtualization-type,Values=hvm' 'Name=root-device-type,Values=ebs') #'Name=ena-support,Values=true')

say () {
    echo >&2 "$*"
}


aws_sh_setup () {
    export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION:-us-west-2}"
    export TMPDIR="${TMPDIR:-/tmp/$(id -u)}/$(basename $0 .sh)/$$"
    rm -rf "$TMPDIR"
    mkdir -p "$TMPDIR"

}
## For JQ usage reference
#aws_list_instances_names () { aws ec2 describe-instances | jq -r '.Reservations[].Instances[] | "\(if .Tags and ([.Tags[] | select( .Key == "Name" )] != []) then .Tags[] | select( .Key == "Name" ) | .Value else "-" end)"'; }

aws_format_images () {  jq -r ".Images[]|[.CreationDate,.ImageId,$(jq_value_or .SriovNetSupport '-'),$(jq_value_or .EnaSupport '-'),.Name]|@tsv" | aws_format_output; }

aws_list_images () { aws ec2 describe-images --output=json --owners "${1:-self}" --filters "Name=name,Values=${2:-*}" "${AWS_AMI_FILTERS[@]}"; }
aws_list_rhel6_images () { aws_list_images $AWS_AMI_OWNER_REDHAT 'RHEL-6.?_HVM_GA*' | aws_format_images; }
aws_list_rhel7_images () { aws_list_images $AWS_AMI_OWNER_REDHAT 'RHEL-7.?_HVM_GA*' | aws_format_images; }
aws_list_el6_images () { aws_list_images $AWS_AMI_MARKETPLACE 'CentOS Linux 6 x86_64 HVM*' | aws_format_images; }
aws_list_el7_images () { aws_list_images $AWS_AMI_MARKETPLACE 'CentOS Linux 7 x86_64 HVM*' | aws_format_images; }
aws_list_ub14_images ()  { aws_list_images $AWS_AMI_OWNER_CANONICAL  '*/hvm-ssd/ubuntu-trusty-14.04-amd64-server-*' | aws_format_images; }
aws_list_ub14_image_latest () { aws_list_ub14_images | aws_jq_images | head -1; }
aws_share_ami () {
    local image_id_and_snapshot= rc=
    image_id_and_snapshot=($(set -o pipefail; aws ec2 describe-images --image-ids "$1" --output=json | \
        jq -r '.Images[]|[.ImageId,.BlockDeviceMappings[0].Ebs.SnapshotId]|@tsv'))
    local snapshot_id="${image_id_and_snapshot[1]}"
    aws ec2 modify-image-attribute --image-id "$1" --launch-permission "{\"Add\":[{\"UserId\":\"$2\"}]}"
    aws ec2 modify-snapshot-attribute --snapshot-id $snapshot_id --attribute createVolumePermission --operation-type remove --user-ids $2
}


aws_list_running () { aws_list_instances_info --filter Name='instance-state-name',Values='running'; }


JQ_TAG_NAME='"\(if .Tags and ([.Tags[] | select( .Key == "Name" )] != []) then .Tags[] | select( .Key == "Name" ) | .Value else "-" end)"'
JQ_TAGS_OTHER='"\(if .Tags then [.Tags[] | select( .Key != "Name") |"\(.Key)=\(.Value)"] | join(",") else "-" end)"'

jq_value_or () {
    echo '"\(if '$1' and '$1' != "" then '$1' else "'${2:-}'" end)"'
}

aws_format_output () {
    sed 's/.000Z//g' | sort -rn | column -t
}

aws_format_instances () {
    jq -r '
    .Reservations[].Instances[] |
        [
         "\(if .Tags and ([.Tags[] | select( .Key == "Name" )] != []) then .Tags[] | select( .Key == "Name" ) | .Value else "-" end)",
         .InstanceId,
         .ImageId,
         .EbsOptimized,
         "\(if .SriovNetSupport then .SriovNetSupport else "-" end)",
         "\(if .EnaSupport then .EnaSupport else "-" end)",
         .State.Name,
         .LaunchTime,
         .PrivateIpAddress,
         "\(if .PublicIpAddress then .PublicIpAddress else "None" end)",
         "\(if .PublicDnsName and .PublicDnsName != "" then .PublicDnsName else "None" end)"
        ] |@tsv' |  aws_format_output
}

aws_list_instances_info () {
    aws ec2 describe-instances "$@" --output=json | aws_format_instances
}

aws_list_instances_info2 () {
    aws ec2 describe-instances | jq -r "
    .Reservations[].Instances[] |
        [
         .LaunchTime,
         .InstanceId,
         .ImageId,
         .InstanceType,
         .State.Name,
         $JQ_TAG_NAME,
         .EbsOptimized,
         $(jq_value_or .SriovNetSupport 'nosriov'),
         $(jq_value_or .EnaSupport 'noena'),
         .PrivateIpAddress,
         $(jq_value_or .PublicIpAddress None),
         $(jq_value_or .PublicDnsName None)
        ] |@tsv" | aws_format_output
}

aws_instance_sriov_enable () {
    aws ec2 modify-instance-attribute --instance-id ${1} --sriov-net-support simple
}

aws_instance_sriov () {
    aws ec2 describe-instance-attribute --instance-id ${1} --attribute sriovNetSupport
}

aws_image_sriov () {
    aws ec2 describe-image-attribute --image-id ${1} --attribute sriovNetSupport
}



aws_show_images () {
    jq -r "
    .Images[] |
         [
          .CreationDate,
          .ImageId,
          .BlockDeviceMappings[0].Ebs.SnapshotId,
          .Name,
          $(jq_value_or .SriovNetSupport),
          $(jq_value_or .EnaSupport),
          $JQ_TAG_NAME,
          $JQ_TAGS_OTHER
        ] |@tsv" | aws_format_output
}

aws_delete_image () {
    local image_id_and_snapshot= rc=
    image_id_and_snapshot=($(set -o pipefail; aws ec2 describe-images --owners self --filters "Name=name,Values=$1" | jq -r '.Images[]|[.ImageId,.BlockDeviceMappings[0].Ebs.SnapshotId]|@tsv'))
    rc=$?
    if [ $rc -ne 0 ]; then
        echo >&2 "ERROR($rc): Failed to find $1"
        return $rc
    fi
    if [ ${#image_id_and_snapshot[@]} -eq 0 ]; then
        echo >&2 "No images found matching $1"
        return 0
    fi
    if test $(( ${#image_id_and_snapshot[@]} % 2 )) -ne 0; then
        echo >&2 "ERROR($rc): Unknown format for image id and snapshot: ${image_id_and_snapshot[@]}"
        return 1
    fi
    if [ -t 1 ]; then
        echo "Deleting ${image_id_and_snapshot[@]}. Sleeping for 5 seconds"
        sleep 5
    fi
    for ((ii=0; ii < ${#image_id_and_snapshot[@]}; ii+=2)); do
        image_id=${image_id_and_snapshot[$ii]}
        snapshot_id=${image_id_and_snapshot[$(( $ii + 1))]}
        echo "Deleting ${image_id} (snapshot_id: ${snapshot_id})"
        aws ec2 deregister-image --image-id "${image_id}" && \
        aws ec2 delete-snapshot --snapshot-id "${snapshot_id}"
    done
}

aws_delete_ami () {
    if [ $# -eq 0 ]; then
        echo >&2 "ERROR: Must specify image-ids"
        return 1
    fi
    aws ec2 describe-images --image-ids "$@" --output=json | aws_format_images
    local image_id_and_snapshot=($(aws ec2 describe-images --image-ids "$@" --output=json | jq -r '.Images[]|[.ImageId,.BlockDeviceMappings[0].Ebs.SnapshotId]|@tsv'))
    for ((ii=0; ii < ${#image_id_and_snapshot[@]}; ii+=2)); do
        image_id=${image_id_and_snapshot[$ii]}
        snapshot_id=${image_id_and_snapshot[$(( $ii + 1))]}
        echo "Deleting ${image_id} (snapshot_id: ${snapshot_id})"
        echo "Sleeping for 5 seconds ..."
        sleep 5
        aws ec2 deregister-image --image-id "${image_id}" && \
        aws ec2 delete-snapshot --snapshot-id "${snapshot_id}"
    done
}

aws_run_instanes () {
    aws ec2 run-instances \
        --image-id ${1} \
        --key-name xcalar-us-west-2 \
        --security-groups default \
        --instance-type ${2:-c4.8xlarge} \
        --output json
}

aws_run_cluster () {
    aws ec2 run-instances \
        --image-id ${1} \
        --count ${2} \
        --key-name xcalar-us-west-2 \
        --security-groups default \
        --instance-type ${3:-c4.8xlarge} \
        --placement AvailabilityZone=us-west-2c,GroupName=${USER}-xcalar-pg,Tenancy=default \
        --output json
}

aws_create_el7_image () {
    local snapshot_id=$1 volume_size=$2
    shift 2
    test -z "$volume_size" && return 1
    aws ec2 register-image --name 'EL-7.3_HVM_GP2_IXGBEVF-4.0.3_ENA-1.1.3-3ac3e0b-BASE v1' \
            --description 'EL7.3 cloud-init + IXGBEVF & ENA drivers' \
            --virtualization-type hvm \
            --root-device-name /dev/sda1 \
            --block-device-mappings '[{"DeviceName":"/dev/sda1","Ebs": { "SnapshotId": "'${snapshot_id}'", "VolumeSize":'${volume_size}',  "DeleteOnTermination": true, "VolumeType": "gp2"}}, { "DeviceName":"/dev/xvdb","VirtualName":"ephemeral0"}, { "DeviceName":"/dev/xvdc","VirtualName":"ephemeral1"}]' \
            --architecture x86_64 \
            --sriov-net-support simple \
            --ena-support
}

# Get something like
# 172.x.x.x   i-0228d0f3b610a5c36     MyXcalar
aws_instances_by_tag () {
    aws ec2 describe-instances \
			--filter 'Name=instance-state-name,Values=running,pending' \
					 'Name=tag-key,Values=aws:cloudformation:stack-name' 'Name=tag-value,Values=my-xcalar' \
			--query  'Reservations[*].Instances[*].[PrivateIpAddress, InstanceId, Tags[?Key==`Name`] | [0].Value]' \
			--output text
}


aws_config_ssh () {
    local since="$(date --date='100 days ago' +'%Y-%m-%d')"
    #aws ec2 describe-instances | jq --arg yest $since -r '.Reservations[].Instances[] | select(.LaunchTime > $yest) | select(.State.Code != 48) | (.Tags[]//[]|select(.Key=="Name")|.Value) as $name | "Host \($name)\n\tHostname \(.PrivateIpAddress)\n"'
    aws ec2 describe-instances | jq --arg yest $since -r '.Reservations[].Instances[] | select(.LaunchTime > $yest) | select(.State.Code != 48) | (.Tags[]//[]|select(.Key=="Name")|.Value) as $name | "Host \($name).aws\n\tHostname \(.PublicDnsName)\n"'
}

aws_describe_stack () {
    aws cloudformation describe-stack-events --stack-name "${1:-${LOGNAME}-xcalar}" | jq -r '.StackEvents[]|[.Timestamp,.StackName,.ResourceStatus,.ResourceType]|@tsv' | column -t
}

aws_subnet_to_zone () {
    aws ec2 describe-subnets --subnet-ids $1 --query 'Subnets[0].AvailabilityZone' --output text
}

aws_spot_price () {
    aws ec2 describe-spot-price-history --availability-zone ${2:-us-west-2c} --instance-types ${1} \
        --product-description "Linux/UNIX (Amazon VPC)" \
        --start-time $(date -d '1 day ago' --utc +%FT%T) \
        --end-time $(date --utc +%FT%T) --output text
}


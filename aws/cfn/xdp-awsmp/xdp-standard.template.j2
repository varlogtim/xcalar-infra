AWSTemplateFormatVersion: '2010-09-09'
Description: Xcalar Data Platform. This template deploys a XDP Cluster to AWS
Parameters:
  InstanceType:
    Type: String
    Description: Xcalar node EC2 Instance type
    ConstraintDescription: Choose an instance type.
    Default: '{{ instance_default | default("r5d.xlarge") }}'
    AllowedValues: {{ instance_types }}
    {#  {% for instance_type in instance_types -%}
    #  - {{ instance_type }}
    #  {%- endfor %} #}
  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances
    Type: AWS::EC2::KeyPair::KeyName
    Default: '{{ key_name | default("xcalar-us-west-2") }}'
{%- if createVpc %}
  VpcCidr:
    Type: String
    MinLength: 9
    MaxLength: 18
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
    ConstraintDescription: Must be a valid CIDR range in the form x.x.x.x/16
    Default: 10.20.0.0/16
  SharedACidr:
    Type: String
    MinLength: 9
    MaxLength: 18
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
    ConstraintDescription: Must be a valid CIDR range in the form x.x.x.x/22
    Default: 10.20.0.0/22
{%- else %}
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC to use for cluster placement (vpc-xxxxxx)
  Subnet:
    Type: AWS::EC2::Subnet::Id
    Description: ID of the private subnet of your VPC (subnet-xxxxxxxx)
{%- endif %}
  AllowedCIDR:
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
    ConstraintDescription: Must be a valid IP CIDR range of the form x.x.x.x/x.
    Description: >-
      Enter the CIDR Block that should have access to this cluster. If unsure, use 0.0.0.0/0 to allow
      access from anywhere. You can also enter a specific IP address in the form of 72.22.33.44/32 (this could be your Work or Home IP).
    Type: String
    MinLength: 9
    MaxLength: 18
  AssociatePublicIpAddress:
    Description: Associate a Public IP address with each instance
    Default: 'true'
    AllowedValues:
      - 'false'
      - 'true'
    Type: String
  AdminUsername:
    Description: Desired username of the XDP Administrator
    Type: String
    MinLength: 5
    MaxLength: 128
  AdminPassword:
    Description: Password for the XDP Administrator
    NoEcho: true
    Type: String
    MinLength: 5
    MaxLength: 128
  ClusterSize:
    Description: Desired cluster size (number of instances)
    MinValue: 0
    MaxValue: 32
    Default: 1
    Type: Number
  RootSize:
    Description: Size of Root Disk in GB
    MinValue: 64
    MaxValue: 4095
    Default: 64
    Type: Number
{%- if enableExistingShare %}
  ExistingShare:
    Description: Existing EFS Share (fs-xxxxxxxx), or leave blank to create one
    Type: String
    Default: ''
{%- endif %}
  ExistingS3:
    Description: Use an existing S3 bucket to load data from, or leave blank to create one. When specifying an existing bucket use only the bucket name. For example, if your bucket is s3://mybucket, specify mybucket.
    Type: String
    Default: ''
  SSLCert:
    Description: Your website's SSL certificate (.crt file). Paste contents of file here.
    Type: String
    Default: ''
  SSLKey:
    Description: Your website's SSL private key (.key file). Paste contents of file here.
    Type: String
    NoEcho: true
    Default: ''
{%- if enableLicense %}
  LicenseKey:
    Description: XDP License Key
    Type: String
    Default: ''
{%- endif %}
Metadata:
  BuildInfo:
{%- if ami.Version %}
    Version: '{{ ami.Version }}'
{%- endif %}
{%- if ami.Build %}
    Build: '{{ ami.Build }}'
{%- endif %}
{%- if ami.Product %}
    Product: '{{ ami.Product }}'
{%- endif %}

  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Xcalar Data Platform
        Parameters:
          - AdminUsername
          - AdminPassword
{%- if enableLicense %}
          - License
{%- endif %}
      - Label:
          default: Security Configuration
        Parameters:
          - AllowedCIDR
          - KeyName
      - Label:
          default: Cluster Configuration
        Parameters:
          - InstanceType
          - ClusterSize
          - ExistingS3
      - Label:
          default: VPC/Network
        Parameters:
{%- if createVpc %}
          - VpcCidr
          - SharedACidr
{%- else %}
          - VpcId
          - Subnet
{%- endif %}
      - Label:
          default: Advanced Options
        Parameters:
          - RootSize
          - AssociatePublicIpAddress
          - SSLCert
          - SSLKey
{%- if enableExistingShare %}
          - ExistingShare
{%- endif %}
    ParameterLabels:
{%- if enableLicense %}
      LicenseKey:
        default: 'XCE License Key:'
{%- endif %}
      AdminUsername:
        default: 'XDP Administrator Username'
      AdminPassword:
        default: 'XDP Administrator Password'
      InstanceType:
        default: 'EC2 Instance Type'
      ClusterSize:
        default: 'Number of instances to launch'
      KeyName:
        default: 'SSH Key Pair'
      AllowedCIDR:
        default: 'Allow Access from CIDR Range'
      ExistingS3:
        default: 'Connect to an existing S3 Bucket'
      AssociatePublicIpAddress:
        default: 'Associate with a public IP address'
      RootSize:
        default: 'Disk size'
{%- if createVpc %}
      VpcCidr:
        default: 'VPC CIDR Range'
      SharedACidr:
        default: 'Subnet CIDR Range'
{%- endif %}
Conditions:
  CreateNewS3: !Equals [!Ref ExistingS3, '']
  NoInstances: !Equals [!Ref ClusterSize, 0]
{%- if enableExistingShare %}
  CreateNewShare: !Equals [!Ref ExistingShare, '']
{%- endif %}
Mappings:
  AWSAMIRegionMap:
{%- for reg in ['us-east-1','us-west-2','us-east-2','us-west-1'] %}
    {{ reg }}:
      {%- if images[reg] and images[reg]['AMZN1HVM'] %}
      AMI: {{ images[reg]['AMZN1HVM'] }}
      {%- elif images[reg] and images[reg]['AMZN2HVM'] %}
      AMI: {{ images[reg]['AMZN2HVM'] }}
      {%- else %}
      AMI: {{ ami_id }}
      {%- endif %}
{%- endfor %}
Resources:
{%- if createVpc %}
  VpcId:
    Type: "AWS::EC2::VPC"
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-VPC'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  IGW:
    Type: "AWS::EC2::InternetGateway"
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-IGW'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  Subnet:
    Type: "AWS::EC2::Subnet"
    Properties:
      AvailabilityZone: !Select [0, !GetAZs ]
      CidrBlock: !Ref SharedACidr
      MapPublicIpOnLaunch: true
      VpcId: !Ref VpcId
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Subnet'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  SubnetRouteTableAssociationPublic:
    Type: "AWS::EC2::SubnetRouteTableAssociation"
    Properties:
      RouteTableId: !Ref RouteTablePublic
      SubnetId: !Ref Subnet
  RouteDefaultPublic:
    Type: "AWS::EC2::Route"
    DependsOn: [GatewayAttachment]
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref IGW
      RouteTableId: !Ref RouteTablePublic
  RouteTablePublic:
    Type: "AWS::EC2::RouteTable"
    Properties:
      VpcId: !Ref VpcId
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-RouteTable'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  GatewayAttachment:
    Type: "AWS::EC2::VPCGatewayAttachment"
    Properties:
      InternetGatewayId: !Ref IGW
      VpcId: !Ref VpcId
  S3Endpoint:
    Type: "AWS::EC2::VPCEndpoint"
    Properties:
      PolicyDocument:
        Statement:
          - Action: "*"
            Effect: Allow
            Resource: "*"
            Principal: "*"
      RouteTableIds:
        - !Ref RouteTablePublic
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      VpcId: !Ref VpcId
#  Ec2Endpoint:
#    Type: "AWS::EC2::VPCEndpoint"
#    Properties:
#      PolicyDocument:
#        Statement:
#          - Action: "*"
#            Effect: Allow
#            Resource: "*"
#            Principal: "*"
#
#      RouteTableIds:
#        - !Ref RouteTablePublic
#      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ec2'
#      VpcId: !Ref VpcId
{%- endif %}
  S3Bucket:
    Type: AWS::S3::Bucket
    Condition: CreateNewS3
{%- if retainPolicy %}
    DeletionPolicy: Retain
{%- endif %}
    Properties:
      AccessControl: Private
  ClusterSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access between nodes, and HTTPS/SSH from the given CIDR.
      VpcId: !Ref 'VpcId'
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref 'AllowedCIDR'
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: !Ref 'AllowedCIDR'
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: !Ref 'AllowedCIDR'
        - IpProtocol: tcp
          FromPort: 10000
          ToPort: 10000
          CidrIp: !Ref 'AllowedCIDR'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ClusterSG'
  ClusterMonitorIngressTCP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'ClusterSG'
      IpProtocol: tcp
      FromPort: 8000
      ToPort: 8000
      SourceSecurityGroupId: !Ref 'ClusterSG'
  ClusterMonitorIngressUDP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'ClusterSG'
      IpProtocol: udp
      FromPort: 8000
      ToPort: 8000
      SourceSecurityGroupId: !Ref 'ClusterSG'
  ClusterIngressHTTP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'ClusterSG'
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      SourceSecurityGroupId: !Ref 'ClusterSG'
  ClusterIngressSSL:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'ClusterSG'
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !Ref 'ClusterSG'
  ClusterIngressAPI:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'ClusterSG'
      IpProtocol: tcp
      FromPort: 18552
      ToPort: 18552
      SourceSecurityGroupId: !Ref 'ClusterSG'
  ClusterIngressProto:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'ClusterSG'
      IpProtocol: tcp
      FromPort: 5000
      ToPort: 5000
      SourceSecurityGroupId: !Ref 'ClusterSG'
  EfsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: EFS Mount Access Security Group
      VpcId: !Ref 'VpcId'
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          DestinationSecurityGroupId: !Ref 'ClusterSG'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          SourceSecurityGroupId: !Ref 'ClusterSG'
  EfsSharedRoot:
    Type: AWS::EFS::FileSystem
{%- if enableExistingShare %}
    Condition: CreateNewShare
{%- endif %}
{%- if retainPolicy %}
    DeletionPolicy: Retain
{%- endif %}
    Properties:
      Encrypted: true
      LifecyclePolicies:
        - TransitionToIA: 'AFTER_30_DAYS'
      FileSystemTags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-EFS'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  EfsMountTarget:
    Type: AWS::EFS::MountTarget
    Properties:
{%- if enableExistingShare %}
      FileSystemId: !If [CreateNewShare, !Ref EfsSharedRoot, !Ref ExistingShare]
{%- else %}
      FileSystemId: !Ref EfsSharedRoot
{%- endif %}
      SubnetId: !Ref 'Subnet'
      SecurityGroups:
        - !Ref 'EfsSecurityGroup'
  PlacementGroup:
    Type: AWS::EC2::PlacementGroup
    Properties:
      Strategy: cluster
  ClusterASG:
    DependsOn: [EfsMountTarget]
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      PlacementGroup: !Ref 'PlacementGroup'
      TerminationPolicies:
        - NewestInstance
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      MinSize: !Ref ClusterSize
      MaxSize: !Ref ClusterSize
      DesiredCapacity: !Ref ClusterSize
      VPCZoneIdentifier:
        - !Ref 'Subnet'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-node'
          PropagateAtLaunch: true
        - Key: FileSystemId
{%- if enableExistingShare %}
          Value: !If [CreateNewShare, !Ref EfsSharedRoot, !Ref ExistingShare]
{%- else %}
          Value: !Ref EfsSharedRoot
{%- endif %}
          PropagateAtLaunch: true
        - Key: MountTarget
          Value: !Ref EfsMountTarget
          PropagateAtLaunch: true
{%- if ami %}
{%- if ami.Version %}
        - Key: Version
          Value: '{{ ami.Version }}'
          PropagateAtLaunch: true
{%- endif %}
{%- if ami.Build %}
        - Key: Build
          Value: '{{ ami.Build }}'
          PropagateAtLaunch: true
{%- endif %}
{%- if ami.Product %}
        - Key: Product
          Value: '{{ ami.Product }}'
          PropagateAtLaunch: true
{%- endif %}
{%- endif %}
    CreationPolicy:
      ResourceSignal:
        Count: !Ref ClusterSize
        Timeout: PT10M
    # WillReplace: true, means a new ASG is stood up and the old one is replaced if the new stack comes up
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: false
      AutoScalingScheduledAction:
        IgnoreUnmodifiedGroupSizeProperties: true
      AutoScalingRollingUpdate:
        MinInstancesInService: 0
        MaxBatchSize: !If [NoInstances ,!Ref 'AWS::NoValue', !Ref 'ClusterSize']
        WaitOnResourceSignals: false
  ClusterEIP:
    Type: AWS::EC2::EIP
{%- if createVpc %}
    DependsOn: [GatewayAttachment]
{%- endif %}
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ClusterEIP'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  AssociateEIP:
    Type: AWS::EC2::EIPAssociation
    Properties:
      AllocationId: !GetAtt ClusterEIP.AllocationId
      NetworkInterfaceId: !Ref ClusterNIC
  ClusterNIC:
    Type: AWS::EC2::NetworkInterface
    Properties:
      SubnetId: !Ref Subnet
      Description: Interface for traffic from the internet to the cluster head node
      GroupSet:
        - !Ref ClusterSG
      SourceDestCheck: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ClusterNIC'
        - Key: StackName
          Value: !Ref 'AWS::StackName'
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          setup:
            - configure_cfn
            - configure_app
          reload:
            - reconfigure_app
        configure_cfn:
          files:
{%- if DEBUG == 1 %}
            /var/lib/cloud/scripts/vendor/bootstrap.sh:
              source: {{ bootstrapUrl }}
              mode: '000755'
              owner: root
              group: root
{%- endif %}
            /etc/xcalar/host.crt:
              content: !Ref SSLCert
              mode: '000644'
              owner: root
              group: root
            /etc/xcalar/host.key:
              content: !Ref SSLKey
              mode: '000640'
              owner: root
              group: xcalar
            /etc/cfn/hooks.d/cfn-asg-reloader.conf:
              content: !Sub |
                [cfn-asg-reloader-hook]
                triggers=post.update
                path=Resources.ClusterASG
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource LaunchTemplate --configsets reload --region ${AWS::Region}
                runas=root
              mode: '000400'
              owner: root
              group: root
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.LaunchTemplate.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource LaunchTemplate --configsets setup --region ${AWS::Region}
                runas=root
              mode: '000400'
              owner: root
              group: root
            /etc/cfn/cfn-hup.conf:
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                verbose=true
                interval=1
              mode: '000400'
              owner: root
              group: root
            /opt/xcalar/xcalar-gui/assets/js/env/cloudEnv.js:
              content: |
                const gDataMart = true;
              mode: '000644'
              owner: xcalar
              group: xcalar
            /var/www/xcalar-gui/s3buckets.json:
              content: !Sub
                - |-
                  {"s3buckets": {
                  "${Name}": {
                    "bucket": "${Bucket}",
                    "prefix": ""
                  }}}
                - Bucket: !If [CreateNewS3, !Ref S3Bucket, !Ref ExistingS3]
                  Name: !If [CreateNewS3, 'S3Bucket', 'ExistingS3']
              mode: '000644'
              owner: xcalar
              group: xcalar
          services:
            sysvinit:
              cfn-hup:
                enabled: true
                ensureRunning: true
                files:
                  - /etc/cfn/cfn-hup.conf
                  - /etc/cfn/hooks.d/cfn-auto-reloader.conf
                  - /etc/cfn/hooks.d/cfn-asg-reloader.conf
        configure_app:
          files:
            /var/lib/cloud/instance/ec2.env:
              content: !Sub
                - |-
                  AWS_DEFAULT_REGION=${AWS::Region}
                  CLUSTER_NAME=${AWS::StackName}
                  BUCKET=${Bucket}
                  SSLCRT="${SSLCert}"
                  SSLKEY="${SSLKey}"
                  NFSHOST=${SharedRoot}
                  SUBNET=${Subnet}
                  NIC=${ClusterNIC}
                - Bucket: !If [CreateNewS3, !Ref S3Bucket, !Ref ExistingS3]
{%- if enableExistingShare %}
                  SharedRoot: !If [CreateNewShare, !Ref EfsSharedRoot, !Ref ExistingShare]
{%- else %}
                  SharedRoot: !Ref EfsSharedRoot
{%- endif %}
              mode: '000400'
              owner: root
              group: root
            /var/lib/cloud/instance/bootstrap-wrapper.sh:
              content: !Sub
                - |-
                  #!/bin/bash
                  log()  {
                    logger --id -p "$1" -t user-data -s <<< "$2"
                  }
                  start=$(date +%s)
                  export PATH=/opt/aws/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/sbin:/bin
                  export AWS_DEFAULT_REGION=${AWS::Region}
                  # The ec2-tags utility prints instance tags as key=value pairs suitable for parsing from bash
                  AWS_AUTOSCALING_GROUPNAME="$(ec2-tags -s -i | tr -d "'" | awk -F'=' '/^AWS_AUTOSCALING_GROUPNAME/{print $2}')"
                  DESIREDCAP=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$AWS_AUTOSCALING_GROUPNAME" --query 'AutoScalingGroups[][DesiredCapacity]'  --output text)
                  bash /var/lib/cloud/scripts/vendor/bootstrap.sh --admin-username "${AdminUsername}" --admin-password "${AdminPassword}" \
                            --cluster-size "$DESIREDCAP" --tag-key "aws:autoscaling:groupName" --tag-value "$AWS_AUTOSCALING_GROUPNAME" --cluster-name "${AWS::StackName}" \
                            --bucket "${Bucket}" --nfs-mount "${SharedRoot}" --subnet "${Subnet}" --nic ${ClusterNIC}
                  rc=$?
                  dt=$(( $(date +%s) - start ))
                  log local0.info "bootstrap.sh returned $rc in $dt seconds"
                  exit $rc
                - Bucket: !If [CreateNewS3, !Ref S3Bucket, !Ref ExistingS3]
{%- if enableExistingShare %}
                  SharedRoot: !If [CreateNewShare, !Ref EfsSharedRoot, !Ref ExistingShare]
{%- else %}
                  SharedRoot: !Ref EfsSharedRoot
{%- endif %}
              mode: '000700'
              owner: root
              group: root
          commands:
            01_runbootstrap:
              cwd: /var/lib/cloud/instance
              command: /bin/bash /var/lib/cloud/instance/bootstrap-wrapper.sh setup
        reconfigure_app:
          commands:
            01_reconfig:
              cwd: /var/lib/cloud/instance
              command: /bin/bash /var/lib/cloud/instance/bootstrap-wrapper.sh reconfigure
    Properties:
      LaunchTemplateName: !Sub '${AWS::StackName}-LaunchTemplate'
      LaunchTemplateData:
        InstanceType: !Ref 'InstanceType'
        IamInstanceProfile:
          Arn: !GetAtt 'IamInstanceProfile.Arn'
        NetworkInterfaces:
          - Description: Primary interface
            AssociatePublicIpAddress: !Ref 'AssociatePublicIpAddress'
            DeleteOnTermination: true
            DeviceIndex: 0
            SubnetId: !Ref 'Subnet'
            Groups:
              - !Ref 'ClusterSG'
        KeyName: !Ref 'KeyName'
        ImageId: !FindInMap
          - AWSAMIRegionMap
          - !Ref 'AWS::Region'
          - AMI
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: !Ref 'RootSize'
              VolumeType: gp2
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            set +e
            log()  {
              logger --id -p "$1" -t user-data -s <<< "$2"
            }
            /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource LaunchTemplate --region ${AWS::Region} -c setup
            rc=$?
            log local0.info "Bootstrap returned $rc"
            /opt/aws/bin/cfn-signal -e $rc  --stack ${AWS::StackName} --resource ClusterASG --region ${AWS::Region}
            exit $rc
  IamInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
      Policies:
        - PolicyName: ClusterPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - autoscaling:DescribeAutoScalingGroups
                Resource:
                  - '*'
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStackResource
                Resource:
                  - '*'
              - Effect: Allow
                Action:
                  - ec2:CreateTags
                  - ec2:DeleteTags
                Resource: !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:instance*'
                Condition:
                  StringEquals:
                    ec2:ResourceTag/aws:cloudformation:stack-name: !Ref 'AWS::StackName'
              - Effect: Allow
                Action:
                  - ec2:DescribeNetworkInterfaces
                  - ec2:AttachNetworkInterface
                  - ec2:DetachNetworkInterface
                Resource:
                  - '*'
              - Effect: Allow
                Action:
                  - autoscaling:UpdateAutoScalingGroup
                  - autoscaling:SetInstanceProtection
                  - autoscaling:TerminateInstanceInAutoScalingGroup
                Resource:
                  - !Sub 'arn:aws:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/*'
                Condition:
                  StringEquals:
                    autoscaling:ResourceTag/aws:cloudformation:stack-name: !Ref 'AWS::StackName'
              - Effect: Allow
                Action:
                  - elasticfilesystem:DescribeMountTargets
                Resource:
                  - '*'
              - Effect: Allow
                Action:
                  - s3:GetBucketLocation
                  - s3:ListBucket
                  - s3:ListBucketMultipartUploads
                  - s3:HeadBucket
                Resource:
                  - !Sub
                    - 'arn:aws:s3:::${Bucket}'
                    - Bucket: !If [CreateNewS3, !Ref S3Bucket, !Ref ExistingS3]
              - Effect: Allow
                Action:
                  - s3:AbortMultipartUpload
                  - s3:DeleteObject
                  - s3:GetObject
                  - s3:ListMultipartUploadParts
                  - s3:PutObject
                Resource:
                  - !Sub
                    - 'arn:aws:s3:::${Bucket}/*'
                    - Bucket: !If [CreateNewS3, !Ref S3Bucket, !Ref ExistingS3]
  IamInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref 'IamInstanceRole'
Outputs:
  URL:
    Description: URL of your new Xcalar Cluster
    Value: !Join ["", ["http://",!Ref 'ClusterEIP']]
  EIP:
    Description: Cluster ElasticIP
    Value: !Ref 'ClusterEIP'
{%- if createVpc %}
  VpcId:
    Description: VPC
    Value: !Ref 'VpcId'
  Subnet:
    Description: Subnet
    Value: !Ref 'Subnet'
{%- endif %}
  S3Bucket:
    Description: User S3 Bucket
    Value: !If [CreateNewS3, !Ref S3Bucket, !Ref ExistingS3]
  EfsSharedRoot:
    Description: Xcalar Shared Root
    Value: !Ref EfsSharedRoot
{%- if enableExistingShare %}
    Condition: CreateNewShare
{%- endif %}
  EfsMountTarget:
    Description: Xcalar Shared Root Mount Target
    Value: !Ref EfsMountTarget
  ClusterASG:
    Description: Cluster Autoscaling Group
    Value: !Ref ClusterASG
  ClusterSG:
    Description: Cluster Security Group
    Value: !Ref ClusterSG
  LaunchTemplate:
    Description: Launch template for cluster
    Value: !Ref LaunchTemplate
# vim: ft=yaml

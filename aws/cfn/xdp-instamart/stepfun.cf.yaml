---
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Description: Step function support for Xcalar Lambda Schedules
Parameters:
  InstanceType:
    Type: String
    Description: Instance Type to launch
    Default: 'r5d.xlarge'
  LaunchTemplate:
    Type: String
    Description: Template used for lanching Ec2 nodes
  NotificationEmail:
    Type: String
    Description: Email address to be notified once work completes
  EventBucket:
    Type: String
    Description: Bucket to monitor
  EventPrefix:
    Type: String
    Description: 'Prefix in bucket to monitor. Eg, s3://Bucket/Prefix/'
  ExistingBucket:
    Type: String
    Description: Your source bucket
  WorkBucket:
    Type: String
    Description: Temporary work bucket
  BaseURL:
    Type: String
    Description: Base URL of the deployment
  ParentStack:
    Type: String
    Description: Name of the parent stack
  EfsSharedRoot:
    Description: EFS to use for Xcalar Shared Roots
    Type: String
Resources:
  SNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      Subscription:
        - Endpoint: !Ref NotificationEmail
          Protocol: "email"

  StatesExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub "states.${AWS::Region}.amazonaws.com"
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: StatesExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "sns:Publish"
                Resource: !Ref SNSTopic
              - Effect: Allow
                Action:
                  - logs:CreateLogDelivery
                  - logs:GetLogDelivery
                  - logs:UpdateLogDelivery
                  - logs:DeleteLogDelivery
                  - logs:ListLogDeliveries
                  - logs:PutResourcePolicy
                  - logs:DescribeResourcePolicies
                  - logs:DescribeLogGroups
                Resource: '*'
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunction"
                Resource:
                  - !GetAtt TerminateEC2.Arn
                  - !GetAtt LaunchCluster.Arn
                  - !GetAtt CheckClusterStatus.Arn
                  - !GetAtt RunSSMCommands.Arn
                  - !GetAtt CheckSSMCommandStatus.Arn
  AddS3NotificationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'lambda.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3FullAccess

  ScheduleUpdateTrigger:
    Type: 'Custom::LambdaTrigger'
    DependsOn: ScheduleUpdateCallPermission
    Properties:
      ServiceToken: !GetAtt 'AddS3Notification.Arn'
      LambdaArn: !GetAtt 'ScheduleUpdateFunction.Arn'
      Bucket: !Ref EventBucket
      Prefix: !Ref EventPrefix

  ScheduleUpdateRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEventBridgeFullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 's3:ListBucket'
                Resource:
                  - !Sub 'arn:aws:s3:::${EventBucket}'
                Condition:
                  StringLike:
                    's3:prefix':
                      - !Sub '${EventPrefix}'
                      - !Sub '${EventPrefix}/*'
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                Resource:
                  - !Sub 'arn:aws:s3:::${EventBucket}/${EventPrefix}/*'

  ScheduleExecuteEventRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - events.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEventBridgeFullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StepAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'states:StartExecution'
                  - 'states:*'
                Resource:
                  - !Ref 'DataAppStateMachine'
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                  - 'iam:GetRole'
                Resource: '*'

  ScheduleUpdateCallPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !Ref ScheduleUpdateFunction
      Action: 'lambda:InvokeFunction'
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Sub 'arn:aws:s3:::${EventBucket}'

  StepStartCallPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !Ref StepStartFunction
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      #SourceAccount: !Ref 'AWS::AccountId'
      #SourceArn: !Sub 'arn:aws:s3:::${EventBucket}'

  ###################
  #
  # Lambda related resources for for Ec2/Cluster Control
  #
  ###################
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        - arn:aws:iam::aws:policy/AWSCloudFormationFullAccess
        - arn:aws:iam::aws:policy/AmazonDynamoDBReadOnlyAccess
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess
        - arn:aws:iam::aws:policy/IAMFullAccess
        - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Policies:
        - PolicyName: "LambdaProxyClusterPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - 's3:*'
                  - "ssm:ListCommands"
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: "Allow"
                Action:
                  - "ssm:PutParameter"
                  - "ssm:GetParameter"
                Resource:
                  - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*"
              - Effect: "Allow"
                Action:
                  - "ssm:SendCommand"
                Resource:
                  - "arn:aws:ssm:*:*:document/*"
              - Effect: "Allow"
                Action:
                  - "ssm:SendCommand"
                  - "elasticfilesystem:DescribeMountTargets"
                Resource: "*"
                #                Resource:
                #  - "arn:aws:ec2:*:*:instance/*"
#                Condition:
#                  StringLike:
#                    "ssm:resourceTag/aws:cloudformation:stack-id":
#                      - !Ref ParentStack
              - Effect: "Allow"
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${ExistingBucket}"
                  - !Sub "arn:aws:s3:::${WorkBucket}"
              - Effect: "Allow"
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${EventBucket}"
              - Effect: "Allow"
                Action:
                  - s3:*
                Resource:
                  - !Sub "arn:aws:s3:::${EventBucket}/${EventPrefix}/*"

  Ec2SSMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - sts:AssumeRole
            Principal:
              Service:
                - ec2.amazonaws.com
            Effect: Allow
      Path: "/"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: "Ec2ProxyClusterPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "kms:DescribeCustomKeyStores"
                  - "kms:ListKeys"
                  - "kms:Decrypt"
                  - "kms:DescribeKey"
                  - "kms:ConnectCustomKeyStore"
                  - "kms:ListGrants"
                  - "ec2:DescribeInstances"
                  - "cloudformation:DescribeStackResource*"
                  - "autoscaling:DescribeAutoScalingGroups"
                  - "elasticfilesystem:DescribeMountTargets"
                  - "autoscaling:CompleteLifecycleAction"
                Resource: "*"
              - Effect: "Allow"
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${ExistingBucket}"
                  - !Sub "arn:aws:s3:::${WorkBucket}"
                  - !Sub "arn:aws:s3:::${EventBucket}"
              - Effect: "Allow"
                Action:
                  - "s3:Put*"
                Resource:
                  - !Sub "arn:aws:s3:::${WorkBucket}/*"
              - Effect: "Allow"
                Action:
                  - 's3:Get*'
                Resource:
                  - !Sub "arn:aws:s3:::${ExistingBucket}"
                  - !Sub "arn:aws:s3:::${WorkBucket}"
                  - !Sub "arn:aws:s3:::${EventBucket}"
  DataAppProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref Ec2SSMRole

  AddS3Notification:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        S3Bucket: !ImportValue sharedinf-lambdabucket
        S3Key: xdp-instamart/80e8e9564c13610f.zip
      Handler: add_notification.lambda_handler
      Role: !GetAtt AddS3NotificationRole.Arn
      Layers:
        - !ImportValue sharedinf-lambdalayer
      Runtime: python3.6
      Timeout: 60

  ScheduleUpdateFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        S3Bucket: !ImportValue sharedinf-lambdabucket
        S3Key: xdp-instamart/80e8e9564c13610f.zip
      Handler: schedule.update_handler
      Role: !GetAtt ScheduleUpdateRole.Arn
      Layers:
        - !ImportValue sharedinf-lambdalayer
      Runtime: python3.6
      Timeout: 100
      Environment:
        Variables:
          StackName: !Ref 'AWS::StackName'
          StackId: !Ref 'AWS::StackId'
          ParentStack: !Ref ParentStack
          EventBucket: !Ref EventBucket
          EventPrefix: !Ref EventPrefix
          StateMachineArn: !Ref DataAppStateMachine
          EventRoleArn: !GetAtt ScheduleExecuteEventRole.Arn

  StepStartFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        S3Bucket: !ImportValue sharedinf-lambdabucket
        S3Key: xdp-instamart/80e8e9564c13610f.zip
      Handler: schedule.startstep_handler
      Layers:
        - !ImportValue sharedinf-lambdalayer
      Description: "Launches a statemachine"
      Environment:
        Variables:
          StateMachineArn: !Ref DataAppStateMachine
          StateMachineName: !GetAtt DataAppStateMachine.Name
          StackName: !Ref 'AWS::StackName'
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.6
      Timeout: 300

  LaunchCluster:
    Type: "AWS::Lambda::Function"
    Properties:
      Code:
        S3Bucket: !ImportValue sharedinf-lambdabucket
        S3Key: xdp-instamart/80e8e9564c13610f.zip
      Handler: schedule.launchcluster_handler
      Layers:
        - !ImportValue sharedinf-lambdalayer
      Description: "Creates cluster to perform DataApp processing"
      Environment:
        Variables:
          InstanceType: !Ref InstanceType
          InstanceArn: !GetAtt DataAppProfile.Arn
          LaunchTemplate: !Ref LaunchTemplate
          BaseURL: !Ref BaseURL
          EfsSharedRoot: !Ref EfsSharedRoot
          Email: !Ref NotificationEmail
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.6
      Timeout: 300

  CheckClusterStatus:
    Type: "AWS::Lambda::Function"
    Properties:
      Code:
        ZipFile: |
          import sys, os
          import boto3
          import json

          client = boto3.client('ec2')

          def lambda_handler(event, context):
              print(json.dumps(event,indent=4))
              instance_ids=event['InstanceIds']
              current_status=checkInstanceStatus(instance_ids) # Hack
              if current_status == 'running':
                  event['HasClusterStarted'] = 'YES'
              else:
                  event['HasClusterStarted'] = 'NO'
              return event

          def checkInstanceStatus(instance_ids):
              status_resp = client.describe_instances(InstanceIds=instance_ids)
              return status_resp['Reservations'][0]['Instances'][0]['State']['Name']

      Description: "Checks whether the cluster is started or not"
      Environment:
        Variables:
          InstanceType: !Ref InstanceType
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.6
      Timeout: 300

  RunSSMCommands:
    Type: "AWS::Lambda::Function"
    Properties:
      Code:
        ZipFile: |
          import boto3
          import os
          import json
          import datetime
          def lambda_handler(event, context):
              print(json.dumps(event))
              client = boto3.client('ssm')
              ec2 = boto3.client('ec2')
              s3 = boto3.client('s3')
              BaseURL = os.environ['BaseURL']
              now = datetime.datetime.now()
              instance_ids = event['InstanceIds']
              Items = []
              print(instance_ids)
              print(ec2.describe_instances(InstanceIds=instance_ids))
              event['Commands'] = []
              command = event['Command']
              command = command.replace('%Y',str(now.year)).replace('%m',str(now.month)).replace('%d',str(now.day))
              command = command.replace('%H',str(now.hour)).replace('%M',str(now.minute)).replace('%S',str(now.second))
              response = client.send_command(
                InstanceIds=[instance_ids[0]],
                DocumentName='AWS-RunShellScript',
                Parameters={
                  'commands': [
                    "yum install -y --enablerepo='xcalar*' su-exec",
                    'systemctl start xcalar.service',
                    f'curl {BaseURL}scripts/runner.sh -o /usr/bin/runner.sh',
                    'chmod +x /usr/bin/runner.sh',
                    f'/usr/bin/runner.sh --runas xcalar -- {command}'
                  ]
                }
              )
              event['Commands'].append(response['Command']['CommandId'])
              return event
      Description: "Send SSM Command to instance"
      Environment:
        Variables:
          InstanceType: !Ref InstanceType
          Bucket: !Ref WorkBucket
          BaseURL: !Ref BaseURL
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.6
      Timeout: 300

  CheckSSMCommandStatus:
    Type: "AWS::Lambda::Function"
    Properties:
      Code:
        ZipFile: |
          import boto3
          import json

          client = boto3.client('ssm')

          def lambda_handler(event, context):
              print(json.dumps(event,indent=4))
              event['commandstatus'] =  "SUCCESS"
              for command_id in event['Commands']:
                  print (command_id)
                  status = check_ssm_command_status(command_id)
                  print (status)
                  if status == 'InProgress':
                      event['commandstatus'] =  "PENDING"
                  if status == 'Failed':
                          event['commandstatus'] =  "FAILED"
                  if status == 'Cancelled':
                          event['commandstatus'] =  "FAILED"
              # handle 3 scenarios: PENDING, SUCCESS, FAILED
              return event

          def check_ssm_command_status(command_id):
              response = client.list_commands(
                  CommandId=command_id
              )
              return response['Commands'][0]['Status']

      Description: "Checks whether all SSM Commands has been executed"
      Environment:
        Variables:
          InstanceType: !Ref InstanceType
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.6
      Timeout: 300

  TerminateEC2:
    Type: "AWS::Lambda::Function"
    Properties:
      Code:
        ZipFile: !Sub |
          import sys, os
          import boto3
          import json

          client = boto3.client('ec2')

          def lambda_handler(event, context):
              print(json.dumps(event,indent=4))
              if not 'InstanceIds' in event:
                  return event
              if 'KeepCluster' in event:
                  if event['KeepCluster']:
                      event['hasClusterTerminated'] = 'running'
                      return event
              instance_ids=event['InstanceIds']
              current_status=terminateInstance(instance_ids)
              event['hasClusterTerminated'] = current_status
              waiter = client.get_waiter('instance_terminated')
              waiter.wait(
                  InstanceIds=instance_ids
              )
              return event

          def terminateInstance(instance_ids):
              status_resp = client.terminate_instances(InstanceIds=instance_ids)
              return status_resp['TerminatingInstances'][0]['CurrentState']['Name']

      Description: "Terminates EC2 instance"
      Environment:
        Variables:
          InstanceType: !Ref InstanceType
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.6
      Timeout: 300

      #DataAppDynamoDBTable:
      #  Type: AWS::DynamoDB::Table
      #  Properties:
      #    AttributeDefinitions:
      #      -
      #        AttributeName: "documentname"
      #        AttributeType: "S"
      #    KeySchema:
      #      -
      #        AttributeName: "documentname"
      #        KeyType: "HASH"
      #    ProvisionedThroughput:
      #      ReadCapacityUnits: "5"
      #      WriteCapacityUnits: "5"
      #    TableName: "Create-Golden-AMI-Metadata"

  DataAppStateMachine:
    Type: "AWS::StepFunctions::StateMachine"
    Properties:
      DefinitionString: !Sub |
          {
            "Comment": "State Machine for reliable DataApp Execution",
            "StartAt": "StartCluster",
            "States": {
              "StartCluster": {
                "Type": "Task",
                "Resource": "${LaunchCluster.Arn}",
                "Next": "ClusterStartCheck"
              },
              "ClusterStartCheck": {
                "Type": "Task",
                "Resource": "${CheckClusterStatus.Arn}",
                "ResultPath": "$",
                "Next": "HasClusterStarted"
              },
              "HasClusterStarted": {
                "Type": "Choice",
                "Choices": [
                  {
                    "Variable": "$.HasClusterStarted",
                    "StringEquals": "YES",
                    "Next": "RunScripts"
                  },
                  {
                    "Variable": "$.HasClusterStarted",
                    "StringEquals": "NO",
                    "Next": "Wait Cluster"
                  }
                ],
                "Default": "Wait Cluster"
              },
              "Wait Cluster": {
                "Type": "Wait",
                "Seconds": 60,
                "Next": "ClusterStartCheck"
              },
              "RunScripts": {
                "Type": "Task",
                "Resource": "${RunSSMCommands.Arn}",
                "ResultPath": "$",
                "Next": "CheckScripts"
              },
              "CheckScripts": {
                "Type": "Task",
                "Resource": "${CheckSSMCommandStatus.Arn}",
                "ResultPath": "$",
                "Next": "HaveScriptsCompleted"
              },
              "HaveScriptsCompleted": {
                "Type": "Choice",
                "Choices": [
                  {
                    "Variable": "$.commandstatus",
                    "StringEquals": "SUCCESS",
                    "Next": "Finish Cluster"
                  },
                  {
                    "Variable": "$.commandstatus",
                    "StringEquals": "PENDING",
                    "Next": "Wait Scripts"
                  },
                  {
                    "Variable": "$.commandstatus",
                    "StringEquals": "FAILED",
                    "Next": "Fail Cluster"
                  }
                ],
                "Default": "Wait Scripts"
              },
              "Wait Scripts": {
                "Type": "Wait",
                "Seconds": 30,
                "Next": "CheckScripts"
              },
              "Finish Cluster": {
                "Type": "Task",
                "Resource": "${TerminateEC2.Arn}",
                "ResultPath": "$",
                "Next": "Send Notification Finished"
              },
              "Send Notification Finished": {
                "Type": "Task",
                "Resource": "arn:aws:states:::sns:publish",
                "Parameters": {
                  "TopicArn": "${SNSTopic}",
                  "Message": "DataApp process completed successfully"
                },
                "ResultPath": "$",
                "End": true
              },
              "Fail Cluster": {
                "Type": "Task",
                "Resource": "${TerminateEC2.Arn}",
                "ResultPath": "$",
                "Next": "Send Notification Failed"
              },
              "Send Notification Failed": {
                "Type": "Task",
                "Resource": "arn:aws:states:::sns:publish",
                "Parameters": {
                  "TopicArn": "${SNSTopic}",
                  "Message": "DataApp process failed"
                },
                "ResultPath": "$",
                "Next": "DefaultState"
              },
              "DefaultState": {
                "Type": "Fail",
                "Error": "DefaultStateError",
                "Cause": "No Matches!"
              }
            }
          }
      RoleArn: !GetAtt [ StatesExecutionRole, Arn ]
# vim: ft=yaml

#!/bin/bash
#
#
#

if [ -z "$XLRINFRADIR" ]; then
    export XLRINFRADIR="$(cd $(dirname ${BASH_SOURCE[0]})/.. && pwd)"
    export PATH=$XLRINFRADIR/bin:$PATH
fi

XREGISTRY="${XREGISTRY:-https://registry.int.xcalar.com}"

# When a script is sourced, you can use this function to get the caller / origin
env_script_file() {
    echo "${BASH_SOURCE[${#BASH_SOURCE[@]} - 1]}"
}

say() {
    echo >&2 "$*"
}

debug_run() {
    test "${DEBUG-1}" = "1" && say "debug: $*" || :
    "$@"
    local rc=$?
    test "${DEBUG-1}" = "1" && test $rc -ne 0 && say "debug: Returned code $rc" || :
    return $rc
}

debug() {
    test "${DEBUG-1}" = "1" && say "debug: $*" || :
}

warn() {
    if test -t 2; then
        YELLOW='\e[33m'
        RESET='\e[0m'
        echo -ne "${YELLOW}WARNING${RESET}: " >&2
        say "$1"
    else
        say "WARNING: $1"
    fi
}

error() {
    if test -t 2; then
        RED='\e[31m'
        RESET='\e[0m'
        echo -ne "${RED}ERROR${RESET}: " >&2
        say "$1"
    else
        say "ERROR: $1"
    fi
}

resource() {
    . $XLRINFRADIR/.env
}

please_use_puppet() {
    if [[ $OSTYPE =~ darwin ]]; then
        error "$1. Please install homebrew https://brew.sh/ for Mac"
    else
        error "$1. Please enroll in puppet: http://wiki.int.xcalar.com/mediawiki/index.php/Puppet"
    fi
}

die_with_status() {
    local rc=$1
    shift
    error "$*"
    exit $rc
}

die() {
    error "$*"
    exit 1
}

strjoin() {
    local IFS="$1"
    shift
    echo "$*"
}

path_remove() {
    # Delete path by parts so we can never accidentally remove sub paths
    while [ $# -gt 0 ]; do
        PATH=${PATH//":$1:"/":"} # delete any instances in the middle
        PATH=${PATH/#"$1:"/}     # delete any instance at the beginning
        PATH=${PATH/%":$1"/}     # delete any instance in the at the end
        shift
    done
}

# Return the age of a file in seconds
file_age() {
    if ! test -f "$1"; then
        echo 9999999
        return 1
    fi
    echo $(($(date +%s) - $(stat -c '%Y' "$1")))
}

# $1 'key="value"' $2 json document
json_set() {
    local tmp="${2}.$$"
    jq -r "$1" "$2" >"$tmp" && mv "$tmp" "$2" && return 0 || return 1
}

json_param() {
    if [ -z "$2" ] && [ -z "$PARAMETERS" ]; then
        die "Need to pass a parameters.json or set PARAMETERS"
    fi
    local v=
    if v="$(jq -r ".parameters${1}" "${2:-$PARAMETERS}")" && [ "$v" != null ]; then
        echo $v
    elif v="$(jq -r "${1}" "${2:-$PARAMETERS}")" && [ "$v" != null ]; then
        echo $v
    else
        return 1
    fi
}

# Convert a json object to shell compatible K=V pairse
json_tokv() {
    jq -r "to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]"
}

json_parameters_merge() {
    jq -r -s '.[0] * .[1] | .parameters | {\
                                           adminEmail, adminUsername, adminPassword, licenseKey, scaleNumber, dataDiskSize,
                                           dnsLabelPrefix: {value:"'$GROUP'"},
                                           installerUrl: {value:"'$INSTALLER_URL'"},
                                           bootstrapUrl: {value:"'$BOOTSTRAP_URL'"}
                                           }|tojson' "$@" --output json
}

## Generic helpers
have_command() {
    command -v "$1" >/dev/null
}

preflight() {
    if ! jq --version | grep -q '^jq-1.5'; then
        please_use_puppet 'Need at least jq version 1.5. Please see https://stedolan.github.io/jq/download/'
    fi
    if ! have_command sshpass; then
        please_use_puppet 'Need to have sshpass installed.'
    fi
    return 0
}

safe_curl() {
    debug_run curl -4 --location --retry 20 --retry-delay 5 --retry-max-time 60 "$@"
}

check_url() {
    local http_code=
    if http_code="$(curl -sL -H 'Range: bytes=0-1' -w '%{http_code}\n' -o /dev/null "$1")"; then
        if [[ $http_code =~ ^20 ]]; then
            return 0
        fi
    fi
    return 1
}

url_exists() {
    local tmpf=$(mktemp) http_code
    if http_code=$(curl -fsL -w '%{http_code}\n' -o $tmpf -I "$1"); then
        if [[ $http_code =~ ^20 ]]; then
            cat $tmpf
            rm $tmpf
            return 0
        fi
    fi
    rm $tmpf
    return 1
}

s3_exists() {
    local bucket_key="${1#s3://}"
    local bucket="${bucket_key%%/*}"
    local key="${bucket_key#*/}"
    aws s3api head-object --bucket $bucket --key $key
}

get_sha1() {
    shasum $1 | cut -d' ' -f1 | cut -c1-8
}

if [ "$(uname -s)" = Darwin ]; then
    readlink_f() {
        (
            target="$1"
            cd "$(dirname $target)"
            target="$(basename $target)"
            while [ -L "$target" ]; do
                target="$(readlink $target)"
                cd "$(dirname $target)"
                target="$(basename $target)"
            done
            echo "$(pwd -P)/$target"
        )
    }
else
    readlink_f() {
        readlink -f "$@"
    }
fi

file_sizemb() {
    echo $(stat -c %b "$1")'/(2*1024)' | bc
}

ip_network() {
    ip route get 8.8.8.8 | head -1 | awk '{print $3}'
}

ip_localaddr() {
    hostname -i
}

ip_cidr() {
    ip -o -f inet addr show | awk '/scope global/ {print $4}' | head -1
}

urlencode() {
    if [ $# -gt 0 ]; then
        printf '%s' "$1" | jq -s -R -r '@uri'
    else
        jq -s -R -r '@uri'
    fi
}

vssh() {
    # try to guess the user's intentions
    (
        unset SSH_AUTH_SOCK
        if [[ $1 =~ ^-mode ]] || [[ $1 =~ ^-role ]]; then
            vault ssh "$@"
        elif [[ $@ =~ jenkins ]]; then
            vault ssh -mode=ca -role=jenkins "$@"
        elif [[ $@ =~ ec2 ]]; then
            vault ssh -mode=ca -role=cloud "$@"
        elif [[ $@ =~ azure ]]; then
            vault ssh -mode=ca -role=cloud "$@"
        elif [[ $@ =~ root ]]; then
            vault ssh -mode=ca -role=admin "$@"
        else
            echo >&2 "Don't understand your vault ssh command: $*"
            return 1
        fi
    )
}

consul_session() {
    if [ $# -lt 2 ]; then
        say "ERROR: Must specify session name"
        return 1
    fi
    echo '{"Node": "'$(hostname -s)'", "Name":"'${1}'","TTL":"'${2:-60s}'"}' \
        | curl -fsS --request PUT --data @- http://127.0.0.1:8500/v1/session/create \
        | jq -r .ID
}

CONSUL_HTTP_ADDR=${CONSUL_HTTP_ADDR-http://127.0.0.1:8500}

acquire_lock() {
    local session_id=$1 task_name=$2 result
    echo "Trying to acquire the lock..."
    result=$(curl -s -XPUT "${CONSUL_HTTP_ADDR}/v1/kv/locks/${task_name}/.lock?acquire=${session_id}")
    [ "${result}" == "true" ] && echo "Lock acquired"
}

release_lock() {
    local session_id=$1 task_name=$2 result
    echo "Releasing the lock..."
    result=$(curl -s -XPUT "${CONSUL_HTTP_ADDR}/v1/kv/locks/${task_name}/.lock?release=${session_id}")
    [ "${result}" == "true" ] && echo "Lock released"
}

destroy_session() {
    local session_id=$1 result
    echo "Destroying the session..."
    result=$(curl -s -XPUT "${CONSUL_HTTP_ADDR}/v1/session/destroy/${session_id}")
    [ "${result}" == "true" ] && echo "Session destroyed"
}

with_lock() {
    local session_id task_name="$1"
    shift
    session_id=$(curl -s -XPUT "${CONSUL_HTTP_ADDR}/v1/session/create" -d "{\"Name\": \"${task_name}\"}" | jq -r '.ID')
    if ! acquire_lock "${session_id}"; then
        destroy_session "${session_id}"
        echo "Unable to acquire the lock."
        echo "The job is probably already running on an other server."
        return
    fi

    eval "$@"
    release_lock "${session_id}"
    destroy_session "${session_id}"
}

##
## Docker registry API
##

registry_repos() {
    curl -s ${XREGISTRY}/v2/_catalog | jq -r '.repositories[]'
}

registry_repo_tags() {
    local repo
    for repo in $(registry_repos); do
        curl -s ${XREGISTRY}/v2/${repo}/tags/list | jq -r .
    done | jq -s -r '.'
}

##
##
## Jenkins helpers
##
JENKINS_URL="${JENKINS_URL:-https://jenkins.int.xcalar.com}"

jenkins_node_online() {
    curl -L --silent "$JENKINS_URL/computer/$1/api/json" | grep --silent '"temporarilyOffline":false'
}

jenkins_node_busy() {
    curl -L --silent "$JENKINS_URL/computer/$1/api/json" | grep --silent '"idle":false'
}

jenkins_toggle_node_online() {
    curl -L --silent "$JENKINS_URL/computer/$1/toggleOffline" --request 'POST' --data 'offlineMessage=Pending node re-image'
}

jenkins_deregister_node() {
    curl -L --silent "$JENKINS_URL/computer/$1/doDelete" --request 'POST' --data ''
}

jenkins_wait_for_node() {
    while jenkins_node_busy $1; do
        sleep 20
        echo -n "."
    done
    echo ""
}

cleanhostname() {
    if [ $# -gt 0 ]; then
        local name
        for name; do
            echo "$name" | sed -r 's/_/-/g; s/([A-Z])/\L\1/g; s/\./-/g; s/^-//; s/-$//;'
        done
    else
        sed -r 's/_/-/g; s/([A-Z])/\L\1/g; s/\./-/g; s/^-//; s/-$//;'
    fi
}
